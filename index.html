<!DOCTYPE html>

<html lang="en">

<!--
    ThreeBall
    A recreation of the classic game "Pinball" or "Flipper" using Three.js
    Developed by:
    - Tomás Viana, nº 108445
-->

<head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1">

    <title> ThreeBall </title>

    <link rel="stylesheet" href="style.css">

    <script type="importmap">
        {
          "imports": {
            "three": "https://threejs.org/build/three.module.js",
            "three/examples/jsm/controls/OrbitControls": "https://threejs.org/examples/jsm/controls/OrbitControls.js",
            "cannon-es": "https://cdn.jsdelivr.net/npm/cannon-es@0.20.0/dist/cannon-es.min.js"
          }
        }
    </script>

    <script type="module">
        import * as THREE from 'three';
        import { OrbitControls } from 'three/examples/jsm/controls/OrbitControls';
        import * as CANNON from 'cannon-es';

        // Inicialização principal
        function init() {
            // Criar tela de intro
            const introScreen = document.createElement('div');
            introScreen.id = 'intro-screen';
            introScreen.innerHTML = `
                <h1>ThreeBall</h1>
                <button id="start-button">Start the Game!!</button>
            `;
            document.body.appendChild(introScreen);

            // Ocultar instruções até que o jogo comece
            const instructionsDiv2 = document.createElement('div');
            instructionsDiv2.id = 'instructions';
            instructionsDiv2.style.display = 'none';
            instructionsDiv2.innerHTML = `
                <kbd>←</kbd><kbd>→</kbd> for Flippers
                <br>
                <kbd>Space</kbd> to launch
            `;
            document.body.appendChild(instructionsDiv2);

            // Configuração básica
            const scene = new THREE.Scene();
            const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
            camera.position.set(0, 12, 7);

            const renderer = new THREE.WebGLRenderer({ antialias: true });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.shadowMap.enabled = true;
            document.body.appendChild(renderer.domElement);

            // Ocultar o canvas do jogo até que o botão de início seja clicado
            renderer.domElement.style.display = 'none';

            // Iniciar o jogo quando o botão for clicado
            document.getElementById('start-button').addEventListener('click', () => {
                // Remover a tela de intro
                document.getElementById('intro-screen').remove();

                // Mostrar o canvas do jogo e as instruções
                renderer.domElement.style.display = 'block';
                instructionsDiv2.style.display = 'block';
            });

            // Controles de órbita
            const controls = new OrbitControls(camera, renderer.domElement);
            controls.target.set(0, 0, -2);
            controls.update();


            // Luzes
            const spotLight1 = new THREE.SpotLight(0xffffff, Math.PI * 25);
            spotLight1.position.set(2.5, 5, 5);
            spotLight1.angle = Math.PI / 4;
            spotLight1.penumbra = 0.5;
            spotLight1.castShadow = true;
            scene.add(spotLight1);

            const spotLight2 = new THREE.SpotLight(0xffffff, Math.PI * 25);
            spotLight2.position.set(-2.5, 5, 5);
            spotLight2.angle = Math.PI / 4;
            spotLight2.penumbra = 0.5;
            spotLight2.castShadow = true;
            scene.add(spotLight2);

            // Física
            const world = new CANNON.World({
                gravity: new CANNON.Vec3(0, -9.8, 3)
            });

            // Materiais
            const objectMaterial = new CANNON.Material('object');
            const slipperyMaterial = new CANNON.Material('slippery');

            // Contato entre materiais
            const slipperyContactMaterial = new CANNON.ContactMaterial(objectMaterial, slipperyMaterial, {
                friction: 0,
                restitution: 0.5,
                contactEquationStiffness: 1e8,
                contactEquationRelaxation: 1
            });
            world.addContactMaterial(slipperyContactMaterial);

            // Plano base
            const planeGeometry = new THREE.PlaneGeometry(25, 25);
            const planeMaterial = new THREE.MeshStandardMaterial({ color: 0x333333 });
            const planeMesh = new THREE.Mesh(planeGeometry, planeMaterial);
            planeMesh.receiveShadow = true;
            planeMesh.rotation.x = -Math.PI / 2;
            planeMesh.position.y = 0;
            scene.add(planeMesh);

            const planeShape = new CANNON.Plane();
            const planeBody = new CANNON.Body({
                mass: 0,
                material: objectMaterial,
                shape: planeShape
            });
            planeBody.quaternion.setFromEuler(-Math.PI / 2, 0, 0);
            planeBody.position.y = 0;
            world.addBody(planeBody);

            // Plano trasparente
            const transparentPlaneGeometry = new THREE.PlaneGeometry(25, 25);
            const transparentPlaneMaterial = new THREE.MeshStandardMaterial({
                color: 0x000000,
                transparent: true,
                opacity: 0,
                side: THREE.DoubleSide
            });
            const transparentPlaneMesh = new THREE.Mesh(transparentPlaneGeometry, transparentPlaneMaterial);
            transparentPlaneMesh.rotation.x = Math.PI / 2;
            transparentPlaneMesh.position.y = 1.5;
            scene.add(transparentPlaneMesh);

            const transparentPlaneShape = new CANNON.Plane();
            const transparentPlaneBody = new CANNON.Body({
                mass: 0,
                material: objectMaterial,
                shape: transparentPlaneShape
            });

            transparentPlaneBody.quaternion.setFromEuler(Math.PI / 2, 0, 0);
            transparentPlaneBody.position.set(0, 1.5, 0);
            world.addBody(transparentPlaneBody);

            // Estado do teclado
            const keys = {};
            document.addEventListener('keydown', event => {
                keys[event.code] = true;
            });
            document.addEventListener('keyup', event => {
                keys[event.code] = false;
            });

            // Função auxiliar para criar paredes
            function createWall(width, height, depth, position, rotation = { x: 0, y: 0, z: 0 }) {
                // Visual
                const wallGeometry = new THREE.BoxGeometry(width, height, depth);
                const wallMaterial = new THREE.MeshNormalMaterial({ color: 0x89cff0 });
                const wallMesh = new THREE.Mesh(wallGeometry, wallMaterial);
                wallMesh.position.copy(position);
                wallMesh.rotation.set(rotation.x, rotation.y, rotation.z);
                wallMesh.castShadow = true;
                scene.add(wallMesh);

                // Física
                const wallShape = new CANNON.Box(new CANNON.Vec3(width / 2, height / 2, depth / 2));
                const wallBody = new CANNON.Body({
                    mass: 0,
                    material: objectMaterial,
                    shape: wallShape
                });
                wallBody.position.copy(position);
                wallBody.quaternion.setFromEuler(rotation.x, rotation.y, rotation.z);
                world.addBody(wallBody);

                return { mesh: wallMesh, body: wallBody };
            }

            // Criar paredes
            createWall(0.25, 1, 4, new THREE.Vector3(-3.4, 0.5, -0.1), { x: 0, y: Math.PI / 8, z: 0 });
            createWall(0.25, 1, 4, new THREE.Vector3(3.4, 0.5, -0.1), { x: 0, y: -Math.PI / 8, z: 0 });
            createWall(0.25, 1, 14, new THREE.Vector3(4.3, 0.5, -1), { x: 0, y: 0, z: 0 });
            createWall(0.5, 1, 16, new THREE.Vector3(-4.17, 0.5, -2), { x: 0, y: 0, z: 0 });
            createWall(0.5, 1, 16, new THREE.Vector3(5.9, 0.5, -2), { x: 0, y: 0, z: 0 });

            // Criar parede redonda
            function createCurvedWall(start, end, radius, height, segments) {
                // Visual representation
                const curve = new THREE.QuadraticBezierCurve3(
                    new THREE.Vector3(start.x, start.y, start.z), // Start point
                    new THREE.Vector3(0, start.y, start.z - radius), // Control point (center of the curve)
                    new THREE.Vector3(end.x, end.y, end.z) // End point
                );

                const tubeGeometry = new THREE.TubeGeometry(curve, segments, 0.5, 8, false);
                const tubeMaterial = new THREE.MeshNormalMaterial({ color: 0x0088ff });
                const tubeMesh = new THREE.Mesh(tubeGeometry, tubeMaterial);
                tubeMesh.castShadow = true;
                scene.add(tubeMesh);

                // Physics approximation
                for (let i = 0; i < segments; i++) {
                    const t1 = i / segments;
                    const t2 = (i + 1) / segments;

                    const point1 = curve.getPoint(t1);
                    const point2 = curve.getPoint(t2);

                    const midPoint = point1.clone().lerp(point2, 0.5);
                    const segmentLength = point1.distanceTo(point2);

                    const segmentShape = new CANNON.Box(new CANNON.Vec3(
                        segmentLength / 2 + 0.1,
                        height / 2,
                        0.3
                    ));

                    const segmentBody = new CANNON.Body({
                        mass: 0,
                        material: objectMaterial,
                        shape: segmentShape
                    });

                    segmentBody.position.set(midPoint.x, midPoint.y + height / 2, midPoint.z);
                    segmentBody.quaternion.setFromEuler(0, Math.atan2(point2.z - point1.z, point2.x - point1.x), 0);

                    world.addBody(segmentBody);
                }
            }

            const start = new THREE.Vector3(-4.17, 0.5, -10);
            const end = new THREE.Vector3(5.9, 0.5, -10);

            createCurvedWall(start, end, 5, 0, 40);

            // Criar bumpers
            function createBumper(position) {
                // Visual
                const bumperGeometry = new THREE.CylinderGeometry(0.5, 0.5, 0.55);
                const bumperMaterial = new THREE.MeshNormalMaterial();
                const bumperMesh = new THREE.Mesh(bumperGeometry, bumperMaterial);
                bumperMesh.position.copy(position);
                bumperMesh.castShadow = true;
                scene.add(bumperMesh);

                // Física
                const bumperShape = new CANNON.Sphere(0.5);
                const bumperBody = new CANNON.Body({
                    mass: 0,
                    material: objectMaterial,
                    shape: bumperShape
                });
                bumperBody.position.copy(position);
                bumperBody.userData = { isBumper: true };
                world.addBody(bumperBody);

                return { mesh: bumperMesh, body: bumperBody, scale: 1 };
            }

            const bumper1 = createBumper(new THREE.Vector3(-2, 0.5, -4));
            const bumper2 = createBumper(new THREE.Vector3(2, 0.5, -4));

            // Criar caixa deslizante
            function createSlidingBox(args, position) {
                // Visual
                const boxGeometry = new THREE.BoxGeometry(args[0], args[1], args[2]);
                const boxMaterial = new THREE.MeshNormalMaterial();
                const boxMesh = new THREE.Mesh(boxGeometry, boxMaterial);
                boxMesh.position.copy(position);
                boxMesh.castShadow = true;
                scene.add(boxMesh);

                // Física
                const boxShape = new CANNON.Box(new CANNON.Vec3(args[0] / 2, args[1] / 2, args[2] / 2));
                const boxBody = new CANNON.Body({
                    mass: 0,
                    material: objectMaterial,
                    shape: boxShape
                });
                boxBody.position.copy(position);
                world.addBody(boxBody);

                return { mesh: boxMesh, body: boxBody, direction: 1, targetPosition: 0 };
            }

            const slidingBox = createSlidingBox([1, 0.5, 0.1], new THREE.Vector3(0, 0.5, -1));

            // Criar flippers
            function createFlipper(position, isLeft) {
                // Visual - base
                const cylinderGeometry = new THREE.CylinderGeometry(0.25, 0.25, 1);
                const cylinderMaterial = new THREE.MeshNormalMaterial();
                const cylinderMesh = new THREE.Mesh(cylinderGeometry, cylinderMaterial);

                // Visual - parte que gira
                const boxGeometry = new THREE.BoxGeometry(2, 0.65, 0.25);
                const boxMaterial = new THREE.MeshNormalMaterial();
                const boxMesh = new THREE.Mesh(boxGeometry, boxMaterial);
                boxMesh.position.set(isLeft ? 1 : -1, 0, 0);

                // Grupo para combinar as partes
                const flipperGroup = new THREE.Group();
                flipperGroup.add(cylinderMesh);
                flipperGroup.add(boxMesh);
                flipperGroup.position.copy(position);
                flipperGroup.castShadow = true;
                scene.add(flipperGroup);

                // Física
                const cylinderShape = new CANNON.Cylinder(0.25, 0.25, 1);
                const boxShape = new CANNON.Box(new CANNON.Vec3(1, 0.25, 0.125));

                const flipperBody = new CANNON.Body({
                    mass: 0,
                    material: objectMaterial
                });

                flipperBody.addShape(cylinderShape);
                flipperBody.addShape(boxShape, new CANNON.Vec3(isLeft ? 1 : -1, 0, 0));
                flipperBody.position.copy(position);
                world.addBody(flipperBody);

                return {
                    mesh: flipperGroup,
                    body: flipperBody,
                    isLeft,
                    targetRotation: isLeft ? -0.2 : 0.2,
                    currentRotation: isLeft ? -0.2 : 0.2
                };
            }

            const leftFlipper = createFlipper(new THREE.Vector3(-2.5, 0.5, 2), true);
            const rightFlipper = createFlipper(new THREE.Vector3(2.5, 0.5, 2), false);

            // Criar mola
            function createSpring(position) {
                // Visual - parte móvel
                const cylinderGeometry = new THREE.CylinderGeometry(0.3, 0.3, 2);
                const cylinderMaterial = new THREE.MeshNormalMaterial();
                const cylinderMesh = new THREE.Mesh(cylinderGeometry, cylinderMaterial);
                cylinderMesh.rotation.x = -Math.PI / 2;
                cylinderMesh.position.set(0, 0, 1);

                // Grupo para combinar as partes
                const springGroup = new THREE.Group();
                springGroup.add(cylinderMesh);
                springGroup.position.copy(position);
                springGroup.castShadow = true;
                scene.add(springGroup);

                // Física
                const cylinderShape = new CANNON.Cylinder(0.3, 0.3, 2);

                const springBody = new CANNON.Body({
                    mass: 0,
                    material: objectMaterial
                });

                const cylinderQuat = new CANNON.Quaternion();
                cylinderQuat.setFromEuler(-Math.PI / 2, 0, 0);
                springBody.addShape(cylinderShape, new CANNON.Vec3(0, 0, 1), cylinderQuat);

                springBody.position.copy(position);
                world.addBody(springBody);

                return {
                    mesh: springGroup,
                    body: springBody,
                    targetPosition: 1,
                    currentPosition: 1,
                    compressed: false,
                    released: false,
                    attachedBall: null,
                    connectionPoint: new CANNON.Vec3(position.x, position.y, position.z - 0.5),
                };
            }

            const spring = createSpring(new THREE.Vector3(5.1, 0.5, 0));

            // Criar bola
            function createBall(position) {
                // Visual
                const ballGeometry = new THREE.SphereGeometry(0.5);
                const ballMaterial = new THREE.MeshStandardMaterial({ color: 0xdddddd });
                const ballMesh = new THREE.Mesh(ballGeometry, ballMaterial);
                ballMesh.position.copy(position);
                ballMesh.castShadow = true;
                scene.add(ballMesh);

                // Física
                const ballShape = new CANNON.Sphere(0.5);
                const ballBody = new CANNON.Body({
                    mass: 1,
                    material: slipperyMaterial,
                    shape: ballShape
                });
                ballBody.position.copy(position);
                world.addBody(ballBody);

                return { mesh: ballMesh, body: ballBody };
            }

            const ball = createBall(new THREE.Vector3(5.1, 0.75, -1.3));
            spring.attachedBall = ball;
            //spring.connectionPoint.set(5.1, 1, -1.3)

            // Detectar colisões
            ball.body.addEventListener('collide', (event) => {
                const otherBody = event.body;
                if (otherBody.userData && otherBody.userData.isBumper) {
                    // Aplicar impulso na direção oposta
                    const contactNormal = new CANNON.Vec3();
                    const contactPoint = event.contact.ni;
                    contactNormal.copy(contactPoint);

                    ball.body.velocity.set(
                        contactNormal.x * 10,
                        contactNormal.y * 10,
                        contactNormal.z * 10
                    );

                    // Animar o bumper
                    if (otherBody === bumper1.body) {
                        bumper1.scale = 1.2;
                    } else if (otherBody === bumper2.body) {
                        bumper2.scale = 1.2;
                    }
                }
            });

            // Adicionar instruções
            const instructionsDiv = document.createElement('div');
            instructionsDiv.id = 'instructions';
            instructionsDiv.innerHTML = `
                <kbd>←</kbd><kbd>→</kbd> for Flippers
                <br>
                <kbd>Space</kbd> to launch
            `;
            document.body.appendChild(instructionsDiv);

            // Função de interpolação
            function lerp(from, to, speed) {
                return from + speed * (to - from);
            }

            // Loop de animação
            const clock = new THREE.Clock();

            function animate() {
                requestAnimationFrame(animate);

                const dt = Math.min(clock.getDelta(), 0.1);
                world.step(1 / 60, dt);

                // Atualizar posições dos objetos
                ball.mesh.position.copy(ball.body.position);
                ball.mesh.quaternion.copy(ball.body.quaternion);

                // Verificar se a bola caiu
                if (ball.body.position.z > 6 || ball.body.position.y < 0 || ball.body.position.y > 1.5) {
                    ball.body.velocity.set(0, 0, 0);
                    ball.body.angularVelocity.set(0, 0, 0);
                    ball.body.position.set(5.1, 0.75, -1);
                    spring.attachedBall = ball;
                    spring.connectionPoint.set(5.1, 2.5, -1.3);
                }

                // Controlar flippers
                if (keys['ArrowLeft']) {
                    leftFlipper.targetRotation = 0.2;
                } else {
                    leftFlipper.targetRotation = -0.2;
                }

                if (keys['ArrowRight']) {
                    rightFlipper.targetRotation = -0.2;
                } else {
                    rightFlipper.targetRotation = 0.2;
                }

                // Interpolar rotação dos flippers
                leftFlipper.currentRotation = lerp(leftFlipper.currentRotation, leftFlipper.targetRotation, 0.8);
                rightFlipper.currentRotation = lerp(rightFlipper.currentRotation, rightFlipper.targetRotation, 0.8);

                leftFlipper.body.quaternion.setFromEuler(0, leftFlipper.currentRotation, 0);
                rightFlipper.body.quaternion.setFromEuler(0, rightFlipper.currentRotation, 0);

                leftFlipper.mesh.quaternion.copy(leftFlipper.body.quaternion);
                rightFlipper.mesh.quaternion.copy(rightFlipper.body.quaternion);

                // Controlar mola
                if (keys['Space']) {
                    spring.targetPosition = 3;
                    spring.speed = dt * 5;
                    spring.compressed = true;
                    spring.released = false;
                    if (spring.attachedBall) {
                        //spring.connectionPoint.z = spring.currentPosition + 1;
                        ball.body.position.copy(spring.connectionPoint);
                        ball.body.velocity.set(0, 0, 0);
                    }
                } else if (spring.compressed) {
                    spring.targetPosition = 1;
                    spring.speed = dt * 15;
                    spring.compressed = false;
                    spring.released = true;
                    if (spring.attachedBall) {
                        const launchForce = 25 * (3 - spring.currentPosition);
                        ball.body.velocity.set(0, 0, -launchForce);
                        spring.attachedBall = null;
                    }
                } else {
                    spring.targetPosition = 1;
                    spring.speed = dt * 10;
                    spring.released = false;
                }

                spring.currentPosition = lerp(spring.currentPosition, spring.targetPosition, spring.speed);
                spring.mesh.children[0].position.z = spring.currentPosition;

                // Atualizar caixa deslizante
                slidingBox.targetPosition += slidingBox.direction * dt;
                if (slidingBox.targetPosition > 2) slidingBox.direction = -1;
                if (slidingBox.targetPosition < -2) slidingBox.direction = 1;

                slidingBox.mesh.position.x = lerp(slidingBox.mesh.position.x, slidingBox.targetPosition, 0.1);
                slidingBox.body.position.x = slidingBox.mesh.position.x;

                // Controlar a interação da mola com a bola
                if (spring.released) {
                    // Calcular distância da mola para a bola
                    const springPos = new THREE.Vector3(
                        spring.body.position.x,
                        spring.body.position.y,
                        spring.body.position.z
                    );
                    const ballPos = new THREE.Vector3(
                        ball.body.position.x,
                        ball.body.position.y,
                        ball.body.position.z
                    );
                    const distance = springPos.distanceTo(ballPos);

                    // Se a bola estiver perto da mola quando soltada
                    if (distance < 2) {
                        // Calcular direção do impulso (da mola para longe)
                        const direction = new THREE.Vector3();
                        direction.subVectors(ballPos, springPos).normalize();

                        // Aplicar impulso proporcional à compressão da mola
                        const springForce = 25 * (spring.targetPosition - spring.currentPosition);
                        ball.body.velocity.set(
                            direction.x * springForce,
                            direction.y * springForce,
                            -springForce
                        );

                        spring.released = false;
                    }
                }

                // Animar bumpers
                bumper1.scale = lerp(bumper1.scale, 1, dt * 10);
                bumper2.scale = lerp(bumper2.scale, 1, dt * 10);

                bumper1.mesh.scale.set(bumper1.scale, 1, bumper1.scale);
                bumper2.mesh.scale.set(bumper2.scale, 1, bumper2.scale);

                renderer.render(scene, camera);
            }

            // Redimensionar janela
            window.addEventListener('resize', () => {
                camera.aspect = window.innerWidth / window.innerHeight;
                camera.updateProjectionMatrix();
                renderer.setSize(window.innerWidth, window.innerHeight);
            });

            animate();
        }

        // Iniciar
        window.addEventListener('DOMContentLoaded', init);
    </script>
</head>

<body>
    <div id="ThreeBall"></div>
</body>

</html>